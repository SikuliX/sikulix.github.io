(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{116:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return h}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=r.a.createContext({}),b=function(e){var t=r.a.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=b(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=b(a),u=n,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||i;return a?r.a.createElement(h,o(o({ref:t},s),{},{components:a})):r.a.createElement(h,o({ref:t},s))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:n,l[1]=o;for(var s=2;s<i;s++)l[s]=a[s];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"},97:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return o})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return b}));var n=a(3),r=a(7),i=(a(0),a(116)),l={id:"pattern",title:"Pattern",sidebar_label:"Pattern"},o={unversionedId:"api/pattern",id:"api/pattern",isDocsHomePage:!1,title:"Pattern",description:"class Pattern",source:"@site/docs\\api\\pattern.md",slug:"/api/pattern",permalink:"/docs/api/pattern",editUrl:"https://github.com/SikuliX/sikulix.github.io/edit/website/docs/api/pattern.md",version:"current",sidebar_label:"Pattern",sidebar:"docs",previous:{title:"Screen",permalink:"/docs/api/screen"},next:{title:"Matching an Image",permalink:"/docs/api/match"}},c=[],s={toc:c};function b(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},s,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"class Pattern")),"\nA pattern is used, to associate an image file with additional attributes used in find operations and when acting on a match object."),Object(i.b)("h5",{id:"minimum-similarity"},"Minimum Similarity:"),Object(i.b)("p",null,"While using a ",Object(i.b)("inlineCode",{parentName:"p"},"Region.find()")," operation, if only an image file is provided, Sikuli searches the region using a default minimum similarity of 0.7. This default value can be changed in Settings.MinSimilarity."),Object(i.b)("p",null,"Using ",Object(i.b)("inlineCode",{parentName:"p"},"similar()")," you can associate a specific similarity value, that will be used as the minimum value, when this pattern object is searched. The IDE supports adjusting the minimum similarity of captured images using the Preview Pane (internally in the script, the images are turned into a pattern object automatically)."),Object(i.b)("h5",{id:"click-point"},"Click Point:"),Object(i.b)("p",null,"Normally when clicking on a match, the center pixel of the associated rectangle is used. With a pattern object, you can define a different click point relative to the center using ",Object(i.b)("inlineCode",{parentName:"p"},"targetOffset()"),"."),Object(i.b)("h5",{id:"masking"},"Masking:"),Object(i.b)("p",null,"Masking with SikuliX image search means, that the corresponding pixels in the image, that have a 0 in the mask pixel, will be ignored during search. Masks are internally created from given images having either black parts (masked on request) or transparency (masked automatically)."),Object(i.b)("p",null,"Images having set some 100% transparency in the PNG-alpha-channel will always be treated as masked images so that the transparent parts are ignored during the search."),Object(i.b)("p",null,"Here we are talking about the cases,"),Object(i.b)("p",null,"where you want an image having black parts to be treated as masked (",Object(i.b)("inlineCode",{parentName:"p"},"Pattern.mask()"),"):"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"maskImg = Pattern(someImage).mask()")),Object(i.b)("p",null,"or that you want an image (having black or transparent parts) to be used as mask for another image (Pattern.mask()):"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"pImg = Pattern(someOtherImage).mask(ImageOrPattern)")),Object(i.b)("p",null,"Be aware: in the latter case, both base image and mask image must have the same size in pixels."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"class Pattern")),"\n",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"Pattern(string)"))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parameters:\tstring \u2013 a path to an image file"),Object(i.b)("li",{parentName:"ul"},"Returns:\tthe pattern object")),Object(i.b)("p",null,"This will initialize a new pattern object without any additional attributes. As long as no pattern methods are used additionally, it is the same as just using the image file name itself in the find operation."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"similar(similarity)")),"\nSet the minimum similarity of the given Pattern object to the specified value."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parameters:\tsimilarity \u2013 the minimum similarity to use in a find operation. The value should be between 0 and 1."),Object(i.b)("li",{parentName:"ul"},"Returns:\tthe pattern object")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"exact()"),"\nSet the minimum similarity of the given Pattern object to 0.99, which means exact match is required."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Returns:\tthe pattern object")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"resize(factor)"),"\nA decimal value greater 0 and not equal to 1 to switch the feature on."),Object(i.b)("p",null,"With this setting you can tell SikuliX to resize the given image before a search operation using the given factor, which is applied to both width and height. The implementation internally uses the standard behavior of resizing a ",Object(i.b)("inlineCode",{parentName:"p"},"Java-AWT-BufferedImage"),". See also: ",Object(i.b)("inlineCode",{parentName:"p"},"Settings.AlwaysResize")),Object(i.b)("p",null,"To switch the feature off again, just assign 0 or 1."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parameters:\tfactor \u2013 a decimal value"),Object(i.b)("li",{parentName:"ul"},"Returns:\tthe pattern object")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"targetOffset(dx, dy)"),"\nFor the given Pattern object define a click offset. By default, the click point is the center of the found match. By setting the target offset, it is possible to specify a click point other than the center. dx and dy will be used to calculate the position relative to the center."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parameters:\t",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"dx \u2013 x offset from the center"),Object(i.b)("li",{parentName:"ul"},"dy \u2013 y offset from the center"))),Object(i.b)("li",{parentName:"ul"},"Returns:\nthe pattern object")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"getFilename()"),"\nGet the filename of the image contained in the Pattern object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Returns:\ta filename as a string")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"getTargetOffset()"),"\nGet the target offset of the Pattern object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Returns:\ta Location object as the target offset")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"mask(","[imageOrPattern]",")")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parameters:\timageOrPattern \u2013 image filename, Image or Pattern")),Object(i.b)("p",null,"If a mask can be derived from ",Object(i.b)("inlineCode",{parentName:"p"},"imageOrPattern")," (image has transparent or black parts or is a Pattern with a mask), then it will become the mask for this pattern."),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"imageOrPattern")," is omitted: The pattern will be treated as masked based on black parts of the image."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Returns:\tthe modified pattern")))}b.isMDXComponent=!0}}]);